# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MBRShapefileGenerator
                                 A QGIS plugin
 This plugin is used to generate shapefiles of map based routing zones stored on the areapoint table
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-04-07
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Dan Cahoon
        email                : dcahoon@korterra.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os.path
import os
import logging
import pandas as pd
import geopandas as gpd
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt, QObject, pyqtSignal
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QListWidgetItem

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .mbr_shapefile_generator_dialog import MBRShapefileGeneratorDialog
from .utility import zoneid_suffixid_combine, build_multipolygon, REQUIRED_HEADERS


class LogEmitter(QObject):
    log_signal = pyqtSignal(str)

class LogHandler(logging.Handler):
    def __init__(self, emitter):
        super().__init__()
        self.emitter = emitter

    def emit(self, record):
        msg = self.format(record)
        self.emitter.log_signal.emit(msg)


class MBRShapefileGenerator:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'MBRShapefileGenerator_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&MBR Shapefile Generator')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        self.dlg = MBRShapefileGeneratorDialog()

        self.df = None
        self.customer_to_zones = {}  # Maps each customerid → set of zone_ids
        self.zone_to_customers = {}  # Maps each zone_id → set of customerids

        # Item lookup dictionaries (to control checkbox states later)
        self.customer_items = {}  # Maps customerid → QListWidgetItem
        self.zone_items = {}      # Maps zone_id → QListWidgetItem

        self.log_emitter = LogEmitter()
        self.log_emitter.log_signal.connect(self.dlg.log_list_widget.addItem)

        self.log_handler = LogHandler(self.log_emitter)
        self.log_handler.setFormatter(logging.Formatter('%(levelname)s - %(asctime)s - %(message)s'))

        self.logger = logging.getLogger("MBRShapefileLogger")
        self.logger.setLevel(logging.DEBUG)
        self.logger.addHandler(self.log_handler)

        self._connect_signals()

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('MBRShapefileGenerator', message)

    def add_action(
            self,
            icon_path,
            text,
            callback,
            enabled_flag=True,
            add_to_menu=True,
            add_to_toolbar=True,
            status_tip=None,
            whats_this=None,
            parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/mbr_shapefile_generator/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'MBR Shapefile Generator'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&MBR Shapefile Generator'),
                action)
            self.iface.removeToolBarIcon(action)

    def _connect_signals(self):
        self.dlg.input_file_widget.fileChanged.connect(
            self.parse_initial_output_dir)
        self.dlg.input_file_widget.fileChanged.connect(
            self.populate_input_list_widget)
        self.dlg.customerid_list_widget.itemChanged.connect(
            self.sync_zone_checkboxes)
        self.dlg.zoneid_list_widget.itemChanged.connect(
            self.sync_customer_checkboxes)
        self.dlg.process_button.clicked.connect(self.process)
        self.dlg.destroyed.connect(self.cleanup)
        
    def cleanup(self):
        if hasattr(self, 'logger') and hasattr(self, 'log_handler'):
            self.logger.removeHandler(self.log_handler)
            self.log_handler = None

    def read_file_to_dataframe(self):
        """Takes the file path from the input file widget and reads the file into a pandas dataframe.
        The function checks if the file exists, if it is a file, and if it is a csv or xlsx file.
        Then it reads the file into a pandas dataframe and cleans it. Assigns the cleaned dataframe to self.df
        or None if the file is not valid.
        """
        path = self.dlg.input_file_widget.filePath()
        if not os.path.exists(path):
            self.logger.error("File does not exist %s", path)
            return None
        if not os.path.isfile(path):
            self.logger.error("File is not a file %s", path)
            return None
        if not path.endswith('.csv') and not path.endswith('.xlsx'):
            self.logger.error("File is not a csv or xlsx %s", path)
            return None
        if path.endswith('csv'):
            df = pd.read_csv(path)
            self.df = self.clean_dataframe(df)
        elif path.endswith('xlsx'):
            df = pd.read_excel(path)
            self.df = self.clean_dataframe(df)
        else:
            self.df = None

    def clean_dataframe(self, df: pd.DataFrame) -> pd.DataFrame | None:
        """Cleans the dataframe by renaming the columns to lowercase and checking for required headers.
        It also creates a new column 'zoneid_suffixid' by combining the 'zoneid' and 'suffixid' columns 
        using the zoneid_suffixid_combine function.

        Args:
            df (pd.DataFrame): geometry dataframe

        Returns:
            pd.DataFrame | None: cleaned dataframe if the required headers are present, None otherwise.
        """
        df.columns = df.columns.str.lower()
        if not all(o in df.columns for o in REQUIRED_HEADERS):
            self.logger.error("Input file missing the following required headers: %s",
                              [o for o in REQUIRED_HEADERS if o not in df.columns])
            return None
        df['zoneid_suffixid'] = df.apply(zoneid_suffixid_combine, axis=1)
        return df

    def parse_initial_output_dir(self):
        """Changes the initial output directory widget to the directory of the input file in the input file widget.
        """
        path = self.dlg.input_file_widget.filePath()
        dir_path = os.path.dirname(path)
        if not os.path.exists(dir_path):
            self.logger.error("Output directory does not exist %s", dir_path)
            return None
        if not os.path.isdir(dir_path):
            self.logger.error(
                "Output directory is not a directory %s", dir_path)
            return None
        self.dlg.output_dir_file_widget.setFilePath(dir_path)

    def populate_input_list_widget(self):
        """Populates the input list widget with the unique customerids and zoneid_suffixids from the dataframe.
        It also creates a mapping of customerids to zoneid_suffixids and zoneid_suffixids to customerids.
        The customerid and zoneid_suffixid checkboxes are set to checked by default.
        The function also clears the list widgets before populating them to avoid duplicates.
        If the dataframe is None, it does nothing.
        """
        self.read_file_to_dataframe()
        if self.df is not None:
            unique_customers = sorted(set(self.df['customerid']))
            unique_zones = sorted(set(self.df['zoneid_suffixid']))
            self.customer_to_zones = self.df.groupby(
                'customerid')['zoneid_suffixid'].apply(set).to_dict()
            # zoneid_suffixid → set of customerids (reverse mapping)
            self.zone_to_customers = self.df.groupby('zoneid_suffixid')[
                'customerid'].apply(set).to_dict()
            self.dlg.customerid_list_widget.clear()
            self.dlg.zoneid_list_widget.clear()

            for customer in unique_customers:
                item = QListWidgetItem(str(customer))
                item.setFlags(item.flags() | Qt.ItemIsUserCheckable)
                item.setCheckState(Qt.Checked)  # Default state: checked
                self.dlg.customerid_list_widget.addItem(item)
                self.customer_items[customer] = item

            for zone in unique_zones:
                item = QListWidgetItem(str(zone))
                item.setFlags(item.flags() | Qt.ItemIsUserCheckable)
                item.setCheckState(Qt.Checked)  # Default state: checked
                self.dlg.zoneid_list_widget.addItem(item)
                self.zone_items[zone] = item

            self.update_process_button_state()

    def sync_zone_checkboxes(self, changed_item: QListWidgetItem):
        """Updates the zone checkboxes based on the customer checkboxes.
        If a customer checkbox is unchecked, all related zone checkboxes are unchecked.

        Args:
            changed_item (QListWidgetItem): List widget item that was changed.
        """
        customer = changed_item.text()
        is_checked = changed_item.checkState() == Qt.Checked
        related_zones = self.customer_to_zones.get(customer, set())
        if not is_checked:
            self.dlg.zoneid_list_widget.blockSignals(True)
            for zone in related_zones:
                item = self.zone_items.get(zone)
                if item and item.checkState() != Qt.Unchecked:
                    item.setCheckState(Qt.Unchecked)
            self.dlg.zoneid_list_widget.blockSignals(False)
        self.update_process_button_state()

    def sync_customer_checkboxes(self, changed_item: QListWidgetItem):
        """Updates the customer checkboxes based on the zone checkboxes. If all 
        zones for a customer are unchecked, the customer checkbox is unchecked.
        If any zone for a customer is checked, the customer checkbox is checked.

        Args:
            changed_item (QListWidgetItem): List widget item that was changed.
        """
        zone = changed_item.text()
        related_customers = self.zone_to_customers.get(zone, set())

        self.dlg.customerid_list_widget.blockSignals(True)
        for customer in related_customers:
            zones_for_customer = self.customer_to_zones.get(customer, set())
            checked_zones = sum(
                self.zone_items[z].checkState() == Qt.Checked
                for z in zones_for_customer
                if z in self.zone_items
            )
            customer_item = self.customer_items.get(customer)
            if customer_item:
                if checked_zones > 0:
                    customer_item.setCheckState(Qt.Checked)
                else:
                    customer_item.setCheckState(Qt.Unchecked)
        self.dlg.customerid_list_widget.blockSignals(False)
        self.update_process_button_state()

    def update_process_button_state(self):
        """Performs a sequence of checks to determine if the process button should be enabled or disabled.
        The checks include:
        - If the input file exists and is a valid file
        - If the input file is a csv or xlsx file
        - If the dataframe is not None
        - If the customerid list widget has items
        - If the zoneid list widget has items
        - If at least one customerid is selected
        - If at least one zoneid_suffixid is selected
        If any of these checks fail, the process button is disabled and a tooltip is set to inform the user.
        If all checks pass, the process button is enabled and a tooltip is set to inform the user.
        """
        if not os.path.isfile(self.dlg.input_file_widget.filePath()):
            self.dlg.process_button.setEnabled(False)
            self.dlg.process_button.setToolTip(
                "Please select a valid input file.")
            return
        if not self.dlg.input_file_widget.filePath().endswith('.csv') and not self.dlg.input_file_widget.filePath().endswith('.xlsx'):
            self.dlg.process_button.setEnabled(False)
            self.dlg.process_button.setToolTip("File is not a csv or xlsx")
            return
        if self.df is None:
            self.dlg.process_button.setEnabled(False)
            self.dlg.process_button.setToolTip("Unable to read input file.")
            return
        if self.dlg.customerid_list_widget.count() == 0:
            self.dlg.process_button.setEnabled(False)
            self.dlg.process_button.setToolTip(
                "No customerids found in input file.")
            return
        if self.dlg.zoneid_list_widget.count() == 0:
            self.dlg.process_button.setEnabled(False)
            self.dlg.process_button.setToolTip(
                "No zoneid_suffixids found in input file.")
            return
        if all(item.checkState() == Qt.Unchecked for item in self.customer_items.values()):
            self.dlg.process_button.setEnabled(False)
            self.dlg.process_button.setToolTip(
                "Please select at least one customerid.")
            return
        if all(item.checkState() == Qt.Unchecked for item in self.zone_items.values()):
            self.dlg.process_button.setEnabled(False)
            self.dlg.process_button.setToolTip(
                "Please select at least one zoneid_suffixid.")
            return
        self.dlg.process_button.setEnabled(True)
        self.dlg.process_button.setToolTip(
            "Click to process the selected customers and zones.")

    def process(self):
        """Processes the selected customers and zones, creating files/layers for each selected zone.
        The function first creates a directory for each customerid in the output directory.
        Then it iterates through the selected customers and zones, creating a shapefile or KML file for each zone.
        The shapefile or KML file is created using the geopandas library and the build_multipolygon function.
        """
        selected_customers = [
            cid for cid, item in self.customer_items.items()
            if item.checkState() == Qt.Checked
        ]
        selected_zones = [
            zid for zid, item in self.zone_items.items()
            if item.checkState() == Qt.Checked
        ]
        for customerid in selected_customers:
            # Add logic for geodatabase creation later
            output_dir = os.path.join(self.dlg.output_dir_file_widget.filePath(), customerid.lower())
            if not os.path.exists(output_dir):
                os.makedirs(output_dir)
            customer_zones = self.df['zoneid_suffixid'][self.df['customerid'] == customerid].unique()
            for zone in customer_zones:
                if zone not in selected_zones:
                    continue
                zone_df = self.df[self.df['zoneid_suffixid'] == zone]
                polygon = build_multipolygon(zone_df)
                gdf = gpd.GeoDataFrame(
                    {'geometry': [polygon]},
                    crs='EPSG:4326'
                )
                if self.dlg.output_type_combo_box.currentText() == 'KML':
                    gdf.to_file(os.path.join(output_dir, f"{zone}.kml"), driver='KML')
                elif self.dlg.output_type_combo_box.currentText() == 'Shapefile':
                    gdf.to_file(os.path.join(output_dir, f"{zone}.shp"), driver='ESRI Shapefile')
            
            
    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
