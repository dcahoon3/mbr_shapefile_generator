# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MBRShapefileGenerator
                                 A QGIS plugin
 This plugin is used to generate shapefiles of map based routing zones stored on the areapoint table
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-04-07
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Dan Cahoon
        email                : dcahoon@korterra.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os.path
import os
import logging
import pandas as pd
import geopandas as gpd
from qgis.core import QgsProject, QgsVectorLayer, QgsLayerTreeLayer
from qgis.utils import iface
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt, QObject, pyqtSignal, QThread
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QListWidgetItem

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .mbr_shapefile_generator_dialog import MBRShapefileGeneratorDialog
from .utility import zoneid_suffixid_combine, build_multipolygon, REQUIRED_HEADERS, HELP_DOCUMENTATION
import webbrowser


class QTextEditLogger(QObject, logging.Handler):
    """Custom logging handler to redirect log messages to a QPlainTextEdit widget.

    Args:
        QObject (QObject): QObject
        logging (logging.Handler): logging.Handler
    """
    log_signal = pyqtSignal(str)

    def __init__(self, parent=None):
        QObject.__init__(self, parent)
        logging.Handler.__init__(self)
    
    def emit(self, record):
        msg = self.format(record)
        self.log_signal.emit(msg)
        
class ProcessWorker(QObject):
    """Worker thread for processing the shapefile generation.

    Args:
        QObject (QObject): QObject
    """
    progress = pyqtSignal(int)
    display_layers = pyqtSignal(list)
    log_message = pyqtSignal(int, str)  # level, message
    finished = pyqtSignal()
    
    def __init__(self, df, selected_customers, selected_zones, output_dir, output_type):
        super().__init__()
        self.df = df
        self.selected_customers = selected_customers
        self.selected_zones = selected_zones
        self.output_dir = output_dir
        self.output_type = output_type
        
    def run(self):
        """Processes the dataframe and generates shapefiles or KML files for the selected customers and zones.
        The function first creates a directory for each customerid in the output directory.
        Then it iterates through the selected customers and zones, creating a shapefile or KML file for each zone.
        The shapefile or KML file is created using the geopandas library and the build_multipolygon function.
        The function emits log messages for each step of the process, including errors and warnings.
        The function also emits a progress signal for each zone processed.
        Finally, it emits a finished signal when the process is complete.
        """
        final_datasets = []
        for customerid in self.selected_customers:
            # Add logic for geodatabase creation later
            output_dir = os.path.join(self.output_dir, customerid.lower())
            if not os.path.exists(output_dir):
                os.makedirs(output_dir)
            customer_zones = self.df['zoneid_suffixid'][self.df['customerid'] == customerid].unique()
            for i, zone in enumerate(customer_zones):
                if zone not in self.selected_zones:
                    continue
                zone_df = self.df[self.df['zoneid_suffixid'] == zone]
                try:
                    polygon = build_multipolygon(zone_df)
                    self.log_message.emit(logging.DEBUG, f"Polygon successfully built for zone {zone}")
                except Exception as e:
                    self.log_message.emit(logging.ERROR, f"Error building polygon for zone {zone}: {str(e)}")
                    continue
                num_polygons = len(polygon.geoms) if hasattr(polygon, 'geoms') else 1
                num_holes = sum(len(poly.interiors) for poly in polygon.geoms) if hasattr(polygon, 'geoms') else len(polygon.interiors)
                self.log_message.emit(logging.INFO, f"Zone {zone} generated: {num_polygons} polygon parts, {num_holes} holes")
                gdf = gpd.GeoDataFrame(
                    {'geometry': [polygon]},
                    crs='EPSG:4326'
                )
                
                path = None
                output_ext = 'kml' if self.output_type == 'KML' else 'shp'
                path = os.path.join(output_dir, f"{zone}.{output_ext}")
                if os.path.exists(path):
                    try:
                        os.remove(path)
                        self.log_message.emit(logging.INFO, f"Existing file at {path} removed.")
                    except Exception as e:
                        self.log_message.emit(logging.ERROR, f"Failed to remove existing file at {path}: {str(e)}")
                        continue

                try:
                    if self.output_type == 'KML':
                        gdf.to_file(path, driver='KML')
                        self.log_message.emit(logging.INFO, f"KML file created for zone {zone}")
                    elif self.output_type == 'Shapefile':
                        gdf.to_file(path, driver='ESRI Shapefile')
                        self.log_message.emit(logging.INFO, f"Shapefile created for zone {zone}")
                except Exception as e:
                    self.log_message.emit(logging.ERROR, f"Failed to create file for zone {zone} at {path}: {str(e)}")
                    continue
                final_datasets.append({
                    'customerid': customerid,
                    'zoneid_suffixid': zone,
                    'path': path
                })
                self.progress.emit(i + 1)
        self.display_layers.emit(final_datasets)
        self.finished.emit()


class MBRShapefileGenerator:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'MBRShapefileGenerator_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&MBR Shapefile Generator')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        self.dlg = MBRShapefileGeneratorDialog()

        self.df = None
        self.customer_to_zones = {}  # Maps each customerid → set of zone_ids
        self.zone_to_customers = {}  # Maps each zone_id → set of customerids

        # Item lookup dictionaries (to control checkbox states later)
        self.customer_items = {}  # Maps customerid → QListWidgetItem
        self.zone_items = {}      # Maps zone_id → QListWidgetItem

        self.logger = logging.getLogger()
        for handler in list(self.logger.handlers):
            self.logger.removeHandler(handler)
            
        self.log_handler = QTextEditLogger(self.dlg)
        self.log_handler.setFormatter(logging.Formatter('%(levelname)s - %(message)s'))
        self.log_handler.log_signal.connect(self.append_log_to_widget)

        self.logger.addHandler(self.log_handler)
        self.logger.setLevel(logging.DEBUG)
        
        self.thread = None
        self.worker = None

        self._connect_signals()

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('MBRShapefileGenerator', message)

    def add_action(
            self,
            icon_path,
            text,
            callback,
            enabled_flag=True,
            add_to_menu=True,
            add_to_toolbar=True,
            status_tip=None,
            whats_this=None,
            parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/mbr_shapefile_generator/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'MBR Shapefile Generator'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&MBR Shapefile Generator'),
                action)
            self.iface.removeToolBarIcon(action)

    def _connect_signals(self):
        """Connects signals to slots for the dialog elements.
        """
        self.dlg.input_file_widget.fileChanged.connect(
            self.parse_initial_output_dir)
        self.dlg.input_file_widget.fileChanged.connect(
            self.populate_input_list_widget)
        self.dlg.customerid_list_widget.itemChanged.connect(
            self.sync_zone_checkboxes)
        self.dlg.zoneid_list_widget.itemChanged.connect(
            self.sync_customer_checkboxes)
        self.dlg.process_button.clicked.connect(self.process)
        self.dlg.button_box.button(self.dlg.button_box.Reset).clicked.connect(self.reset_ui)
        self.dlg.button_box.button(self.dlg.button_box.Help).clicked.connect(self.open_help_url)

    def open_help_url(self):
        """Opens the help documentation URL in the default web browser."""
        webbrowser.open(HELP_DOCUMENTATION)
        
    def append_log_to_widget(self, msg):
        """Changes the logging mechanism to append the log message to the log text edit widget in the dialog.
        This is done by emitting a signal from the QTextEditLogger class and connecting it to this method.

        Args:
            msg (str): log message
        """
        if self.dlg and self.dlg.log_text_edit:
            self.dlg.log_text_edit.appendPlainText(msg)

    def read_file_to_dataframe(self):
        """Takes the file path from the input file widget and reads the file into a pandas dataframe.
        The function checks if the file exists, if it is a file, and if it is a csv or xlsx file.
        Then it reads the file into a pandas dataframe and cleans it. Assigns the cleaned dataframe to self.df
        or None if the file is not valid.
        """
        path = self.dlg.input_file_widget.filePath()
        if not os.path.exists(path):
            self.logger.error("File does not exist %s", path)
            return None
        if not os.path.isfile(path):
            self.logger.error("File is not a file %s", path)
            return None
        if not path.endswith('.csv') and not path.endswith('.xlsx'):
            self.logger.error("File is not a csv or xlsx %s", path)
            return None
        if path.endswith('csv'):
            df = pd.read_csv(path)
            self.df = self.clean_dataframe(df)
        elif path.endswith('xlsx'):
            df = pd.read_excel(path)
            self.df = self.clean_dataframe(df)
        else:
            self.df = None

    def clean_dataframe(self, df: pd.DataFrame) -> pd.DataFrame | None:
        """Cleans the dataframe by renaming the columns to lowercase and checking for required headers.
        It also creates a new column 'zoneid_suffixid' by combining the 'zoneid' and 'suffixid' columns 
        using the zoneid_suffixid_combine function.

        Args:
            df (pd.DataFrame): geometry dataframe

        Returns:
            pd.DataFrame | None: cleaned dataframe if the required headers are present, None otherwise.
        """
        df.columns = df.columns.str.lower()
        if not all(o in df.columns for o in REQUIRED_HEADERS):
            self.logger.error("Input file missing the following required headers: %s",
                              [o for o in REQUIRED_HEADERS if o not in df.columns])
            self.dlg.process_button.setToolTip(f"Input file missing the following required headers: {[o for o in REQUIRED_HEADERS if o not in df.columns]}")
            return None
        df['zoneid_suffixid'] = df.apply(zoneid_suffixid_combine, axis=1)
        unique_customers = df['customerid'].nunique()
        unique_zones = df['zoneid_suffixid'].nunique()
        self.logger.info("Unique customerids: %d", unique_customers)
        self.logger.info("Unique zoneid_suffixids: %d", unique_zones)
        return df

    def parse_initial_output_dir(self):
        """Changes the initial output directory widget to the directory of the input file in the input file widget.
        """
        path = self.dlg.input_file_widget.filePath()
        dir_path = os.path.dirname(path)
        if not os.path.exists(dir_path):
            self.logger.error("Output directory does not exist %s", dir_path)
            return None
        if not os.path.isdir(dir_path):
            self.logger.error(
                "Output directory is not a directory %s", dir_path)
            return None
        self.dlg.output_dir_file_widget.setFilePath(dir_path)

    def populate_input_list_widget(self):
        """Populates the input list widget with the unique customerids and zoneid_suffixids from the dataframe.
        It also creates a mapping of customerids to zoneid_suffixids and zoneid_suffixids to customerids.
        The customerid and zoneid_suffixid checkboxes are set to checked by default.
        The function also clears the list widgets before populating them to avoid duplicates.
        If the dataframe is None, it does nothing.
        """
        self.read_file_to_dataframe()
        if self.df is not None:
            unique_customers = sorted(set(self.df['customerid']))
            unique_zones = sorted(set(self.df['zoneid_suffixid']))
            self.customer_to_zones = self.df.groupby(
                'customerid')['zoneid_suffixid'].apply(set).to_dict()
            # zoneid_suffixid → set of customerids (reverse mapping)
            self.zone_to_customers = self.df.groupby('zoneid_suffixid')[
                'customerid'].apply(set).to_dict()
            self.dlg.customerid_list_widget.clear()
            self.dlg.zoneid_list_widget.clear()

            for customer in unique_customers:
                item = QListWidgetItem(str(customer))
                item.setFlags(item.flags() | Qt.ItemIsUserCheckable)
                item.setCheckState(Qt.Checked)  # Default state: checked
                self.dlg.customerid_list_widget.addItem(item)
                self.customer_items[customer] = item

            for zone in unique_zones:
                item = QListWidgetItem(str(zone))
                item.setFlags(item.flags() | Qt.ItemIsUserCheckable)
                item.setCheckState(Qt.Checked)  # Default state: checked
                self.dlg.zoneid_list_widget.addItem(item)
                self.zone_items[zone] = item

            self.update_process_button_state()

    def sync_zone_checkboxes(self, changed_item: QListWidgetItem):
        """Updates the zone checkboxes based on the customer checkboxes.
        If a customer checkbox is unchecked, all related zone checkboxes are unchecked.

        Args:
            changed_item (QListWidgetItem): List widget item that was changed.
        """
        customer = changed_item.text()
        is_checked = changed_item.checkState() == Qt.Checked
        related_zones = self.customer_to_zones.get(customer, set())
        if not is_checked:
            self.dlg.zoneid_list_widget.blockSignals(True)
            for zone in related_zones:
                item = self.zone_items.get(zone)
                if item and item.checkState() != Qt.Unchecked:
                    item.setCheckState(Qt.Unchecked)
            self.dlg.zoneid_list_widget.blockSignals(False)
        self.update_process_button_state()

    def sync_customer_checkboxes(self, changed_item: QListWidgetItem):
        """Updates the customer checkboxes based on the zone checkboxes. If all 
        zones for a customer are unchecked, the customer checkbox is unchecked.
        If any zone for a customer is checked, the customer checkbox is checked.

        Args:
            changed_item (QListWidgetItem): List widget item that was changed.
        """
        zone = changed_item.text()
        related_customers = self.zone_to_customers.get(zone, set())

        self.dlg.customerid_list_widget.blockSignals(True)
        for customer in related_customers:
            zones_for_customer = self.customer_to_zones.get(customer, set())
            checked_zones = sum(
                self.zone_items[z].checkState() == Qt.Checked
                for z in zones_for_customer
                if z in self.zone_items
            )
            customer_item = self.customer_items.get(customer)
            if customer_item:
                if checked_zones > 0:
                    customer_item.setCheckState(Qt.Checked)
                else:
                    customer_item.setCheckState(Qt.Unchecked)
        self.dlg.customerid_list_widget.blockSignals(False)
        self.update_process_button_state()

    def update_process_button_state(self):
        """Performs a sequence of checks to determine if the process button should be enabled or disabled.
        The checks include:
        - If the input file exists and is a valid file
        - If the input file is a csv or xlsx file
        - If the dataframe is not None
        - If the customerid list widget has items
        - If the zoneid list widget has items
        - If at least one customerid is selected
        - If at least one zoneid_suffixid is selected
        If any of these checks fail, the process button is disabled and a tooltip is set to inform the user.
        If all checks pass, the process button is enabled and a tooltip is set to inform the user.
        """
        if not os.path.isfile(self.dlg.input_file_widget.filePath()):
            self.dlg.process_button.setEnabled(False)
            self.dlg.process_button.setToolTip(
                "Please select a valid input file.")
            return
        if not self.dlg.input_file_widget.filePath().endswith('.csv') and not self.dlg.input_file_widget.filePath().endswith('.xlsx'):
            self.dlg.process_button.setEnabled(False)
            self.dlg.process_button.setToolTip("File is not a csv or xlsx")
            return
        if self.df is None:
            self.dlg.process_button.setEnabled(False)
            self.dlg.process_button.setToolTip("Unable to read input file.")
            return
        if self.dlg.customerid_list_widget.count() == 0:
            self.dlg.process_button.setEnabled(False)
            self.dlg.process_button.setToolTip(
                "No customerids found in input file.")
            return
        if self.dlg.zoneid_list_widget.count() == 0:
            self.dlg.process_button.setEnabled(False)
            self.dlg.process_button.setToolTip(
                "No zoneid_suffixids found in input file.")
            return
        if all(item.checkState() == Qt.Unchecked for item in self.customer_items.values()):
            self.dlg.process_button.setEnabled(False)
            self.dlg.process_button.setToolTip(
                "Please select at least one customerid.")
            return
        if all(item.checkState() == Qt.Unchecked for item in self.zone_items.values()):
            self.dlg.process_button.setEnabled(False)
            self.dlg.process_button.setToolTip(
                "Please select at least one zoneid_suffixid.")
            return
        self.dlg.process_button.setEnabled(True)
        self.dlg.process_button.setToolTip(
            "Click to process the selected customers and zones.")

    def process(self):
        """Processes the selected customers and zones, creating files/layers for each selected zone.
        The function first creates a directory for each customerid in the output directory.
        Then it iterates through the selected customers and zones, creating a shapefile or KML file for each zone.
        The shapefile or KML file is created using the geopandas library and the build_multipolygon function.
        """
        selected_customers = [
            cid for cid, item in self.customer_items.items()
            if item.checkState() == Qt.Checked
        ]
        selected_zones = [
            zid for zid, item in self.zone_items.items()
            if item.checkState() == Qt.Checked
        ]
        self.dlg.progress_bar.setMaximum(len(selected_zones))
        self.dlg.progress_bar.setValue(0)

        if self.thread is not None:
            self.thread.quit()
            self.thread.wait()
            self.thread = None
            self.worker = None
            
        self.thread = QThread()
        self.worker = ProcessWorker(
            df=self.df,
            selected_customers=selected_customers,
            selected_zones=selected_zones,
            output_dir=self.dlg.output_dir_file_widget.filePath(),
            output_type=self.dlg.output_type_combo_box.currentText()
        )

        self.worker.moveToThread(self.thread)
        self.worker.display_layers.connect(self.add_multiple_layers_to_map)
        self.worker.log_message.connect(self.handle_worker_logs)
        self.worker.progress.connect(self.dlg.progress_bar.setValue)
        self.worker.finished.connect(lambda: self.zoom_to_layers(selected_customers))
        self.thread.started.connect(self.worker.run)
        self.worker.finished.connect(self.thread.quit)
        self.thread.start()
        self.dlg.process_button.setEnabled(False)
    
    def handle_worker_logs(self, level: int, message: str):
        """Handles the log messages emitted from the worker thread.
        It checks the logging level and emits the appropriate log message to the logger.

        Args:
            level (int): logging level enum
            message (str): log message
        """
        if level == logging.DEBUG:
            self.logger.debug(message)
        elif level == logging.INFO:
            self.logger.info(message)
        elif level == logging.WARNING:
            self.logger.warning(message)
        elif level == logging.ERROR:
            self.logger.error(message)
        elif level == logging.CRITICAL:
            self.logger.critical(message)

    def add_multiple_layers_to_map(self, layers: list):
        """Adds multiple layers to the map canvas.
        The function first checks if the display check box is checked.
        If it is checked, it iterates through the layers and adds each layer to the map canvas.

        Args:
            layers (list): list of dictionaries containing the layer information.
                Each dictionary contains the following keys:
                path: file path to the shapefile or KML file
                customerid: customer id
                zoneid_suffixid: zone id and suffix id combined
        """
        if self.dlg.display_check_box.isChecked():
            for layer in layers:
                self.add_layer_to_map(path=layer['path'], customerid=layer['customerid'], zoneid_suffixid=layer['zoneid_suffixid'])
                

    def add_layer_to_map(self, path: str, customerid: str, zoneid_suffixid: str):
        """Adds a layer to the map canvas and sets the active layer to the newly added layer.
        The layer is added to a group named after the customerid. If the group does not exist, it is created.

        Args:
            path (str): file path to the shapefile or KML file
            customerid (str): customer id
            zoneid_suffixid (str): zone id and suffix id combined
        """
        if path is None:
            return
        layer = QgsVectorLayer(path, f"{zoneid_suffixid}", "ogr")
        if not layer.isValid():
            self.logger.error("Failed to load layer %s", path)
            return
        root = QgsProject.instance().layerTreeRoot()
        group = root.findGroup(customerid)
        if group is None:
            group = root.addGroup(customerid)  # This already adds the group to the root node
        QgsProject.instance().addMapLayer(layer, addToLegend=False)
        group.insertChildNode(0, QgsLayerTreeLayer(layer))
    
    def zoom_to_layers(self, groups: list):
        """Zooms to the extent of the layers in the specified groups.
        The function first checks if the group exists in the QGIS interface.
        If the group exists, it iterates through the layers in the group and combines their extents.
        Finally, it sets the map canvas extent to the combined extent.
        If no valid layers are found, it logs a warning message.

        Args:
            groups (list): List of group names / customer ids to zoom to.
        """
        if self.dlg.display_check_box.isChecked():
            root = QgsProject.instance().layerTreeRoot()
            combined_extent = None

            for group_name in groups:
                group = root.findGroup(group_name)
                if not group:
                    self.logger.warning("Group '%s' not found in QGIS interface.", group_name)
                    continue

                for node in group.findLayers():
                    layer = node.layer()
                    if layer and layer.isValid():
                        if combined_extent is None:
                            combined_extent = layer.extent()
                        else:
                            combined_extent.combineExtentWith(layer.extent())

            if combined_extent is not None:
                iface.mapCanvas().setExtent(combined_extent)
                iface.mapCanvas().refresh()
                self.logger.info("Zoomed to extent of selected groups.")
            else:
                self.logger.warning("No valid layers found to zoom to.")
    
    def reset_ui(self):
        """Resets the UI to its initial state. This includes clearing the input and output file widgets,
        clearing the customerid and zoneid list widgets, and resetting the progress bar.
        It also clears the log text edit widget and disables the process button.
        The function also resets init variables
        """
        self.df = None
        self.customer_to_zones = {}
        self.zone_to_customers = {}
        self.customer_items = {}
        self.zone_items = {}
        self.dlg.customerid_list_widget.clear()
        self.dlg.zoneid_list_widget.clear()
        self.dlg.input_file_widget.setFilePath("")
        self.dlg.output_dir_file_widget.setFilePath("")
        self.dlg.log_text_edit.clear()
        self.dlg.process_button.setEnabled(False)
        self.dlg.output_type_combo_box.setCurrentIndex(0)
        self.dlg.display_check_box.setChecked(True)
        self.dlg.progress_bar.setValue(0)
        self.logger.info("UI reset completed.")
            
            
    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            
        # Prevent multiple instances of the widget
        if self.dlg is not None and self.dlg.isVisible():
            self.dlg.raise_()
            self.dlg.activateWindow()
            return
        
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        
        self.reset_ui()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
